// run using:
// webppl BDA.wppl --require ./refModule/

util.seedRNG(8);

var data = refModule.readCSV("./bdaInput/bda_data.csv");
console.log("Loading data complete...",+data.length+" data points");

var conditions = refModule.readCSV("./bdaInput/unique_conditions.csv");

console.log("Loading unique conditions complete..."+conditions.length+" conditions");

var modelAnalysis = function() {

//   var bdaParams = {
//     lexicon: 'realValued', //uniformDraw(['realValued', 'truthConditional']),
//     // lengthWeight: uniformDraw([0, .25, .5, .75, 1]),
//     noiseType: 'none', // uniformDraw(['none', 'addition', 'replacement']),
// //    noiseRate: uniformDraw([.1, .5]), // uniformDrift({a: 0, b: 1, width: 1/20}),
//     alpha : uniformDraw([1,10,20]), // uniformDrift({a:0,b:40,width:40/20}),
//     typWeight : uniformDraw([0,1,5]),
//     cost_color : uniformDraw([-1,0,1]), // uniformDrift({a:0,b:3,width:3/20}),
//     cost_type : uniformDraw([-1,0,1]),//uniformDrift({a:0,b:3,width:3/20}),
//     color_only_cost : uniformDraw([2, 3, 4]) //uniformDrift({a:0,b:3,width:3/20})
//   };  

  var bdaParams = {
    // lexicon: 'realValued',
    // noiseType: 'none',
    alpha : uniformDrift({a:0,b:20,width:20/20}),
    typWeight : uniformDrift({a:0,b:10,width:10/20}),
    cost_color : uniformDrift({a:-10,b:10,width:20/20}),
    cost_type : uniformDrift({a:-10,b:10,width:20/20})
    // color_only_cost : uniformDrift({a:0,b:10,width:10/20})
    // theta : uniformDrift({a:0,b:1,width:1/20})
  };

  // Substitute in the right lexicon data structure for model
  var modelParams = extend(bdaParams, {
    'lexicon': refModule.getLexicon('realValued')//bdaParams.lexicon)
  });

  var speakerModel = initializeModel(modelParams);
  
  var score = reduce(function(conditionObj, memo) {
    // Extract condition information
    var conditionName = conditionObj.conditionName;
    var context = [[conditionObj.t_color, conditionObj.t_type],
		   [conditionObj.d1_color, conditionObj.d1_type],
		   [conditionObj.d2_color, conditionObj.d2_type]];
    var target = context[0];

    // Run model
    var modelOutput = speakerModel(target, context);

    // Store predictions
    foreach(modelOutput.support(), function(s){
      var key = _.values(conditionObj).concat(s);
      var newPair = _.zipObject([key], [Math.exp(modelOutput.score(s))]);
      globalStore.predictives = extend(globalStore.predictives, newPair);
    });
    
    // condition on data
    var itemData = refModule.getSubset(data, conditionObj);
    return memo + reduce(function(datum, memo) {
      return modelOutput.score(datum.utterance) + memo;
    }, 0, itemData);
  }, 0, conditions);

  console.log(bdaParams);
  console.log(score);

  factor(score);
  return {predictive: globalStore.predictives, params : bdaParams};
};

// var outputERP = Infer({method:'enumerate'}, modelAnalysis);
var outputERP = Infer({method:'MCMC', samples: 500, lag: 2, verbose: true}, modelAnalysis);
// var outputERP = Infer({method:'MCMC', kernel : {HMC: {steps:5, stepSize:.01} }, samples: 10, burn: 5, verbose: true}, modelAnalysis); // seed8

// refModule.bayesianErpWriter(outputERP, "./bdaOutput/noNoise_");
// refModule.bayesianErpWriter(outputERP, "./bdaOutput/noNoise_cocost");
refModule.bayesianErpWriter(outputERP, "./bdaOutput/negcost-mcmc");
