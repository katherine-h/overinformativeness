// Helpers
var foreach = function(lst, fn) {
  var foreach_ = function(i) {
    if (i < lst.length) {
      fn(lst[i]);
      foreach_(i + 1);
    }
  };
  foreach_(0);
};

var colors = ["yellow","orange","red","pink",
	      "green","blue","brown","black"];

// TODO: represent context items as
// {color: ..., type: ...} instead of arrays
var getUtterancesOneFeature = function(context) {
  return _.unique(_.flatten(map(function(itemArr) {
    return [itemArr[0], itemArr[1], itemArr.join('_')];
  },context)));
};

var OverinformativeModel = function(params, context) {

  // Cost of full utterances is sum of individual word costs,
  // unless you just use a color, in which case you incur
  // an additional costx
  var getUtteranceCost = function(utt) {
    var split = utt.split("_");
    if (split.length == 2) {
      console.log(params.cost_color + params.cost_type);
      return params.cost_color + params.cost_type;
    } else {
      return (_.contains(colors, split[0]) ?
	      params.cost_color + params.color_only_cost :
	      params.cost_type);
    }
  };

  // Looks up meaning in given lexicon
  // (if no entry, listener assigns 0 probability)
  var meaning = function(utt, object) {
    var objStr = object.join("_");
    var lexicalEntry = params.lexicon[utt];
    return _.has(lexicalEntry, objStr) ? lexicalEntry[objStr] : -Infinity; 
  };

  // Selects among objects in context using lexicon
  var literalListener = cache(function(utt){
    return Infer({method:'enumerate'},function(){
      var object = uniformDraw(context);
      factor(meaning(utt,object)); 
      return object;
    });
  });

  // what does cache do?
  var speaker = cache(function(target) {
    // list all possible utterances in context
    var possibleutts = getUtterancesOneFeature(context);
    return Infer({method:'enumerate'},function(){
      var utt = uniformDraw(possibleutts);
      var literalListenerERP = literalListener(utt);
      var uttCost = getUtteranceCost(utt);
      var score = params.alpha * literalListenerERP.score(target) - params.lengthWeight * uttCost;
      factor(score); 
      return utt;
    });
  });

  var runModel = function(speakerModel, target) { 
    var speakerERP = speakerModel(target);
    return Infer({method:'enumerate'},function(){
      var utt = sample(speakerERP);
      return utt;
    });
  };

  var runListener = function(listenerModel, utterance) { 
    var listenerERP = listenerModel(utterance);
    return Infer({method:'enumerate'},function(){
      var obj = sample(listenerERP);
      return obj;
    });
  };    

  return {
    runModel : runModel,
    speaker : speaker,
    listener: literalListener,
    runListener : runListener
  };
};
