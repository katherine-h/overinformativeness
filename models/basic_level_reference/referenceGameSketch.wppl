// run using:
// webppl referenceGameSketch.wppl --require refModule/

var condition = function(x){
 factor(x ? 0 : -Infinity);
};

var uniformDraw = function (xs) {
  return xs[randomInteger(xs.length)];
};

var BasicLevelModel = function(domainInfo, alpha, superProb, freqWeight) {
  var tax = domainInfo.tax;

  var labelFitness = function(label, object) {
    var consistentObjs = tax[label];
    return _.has(consistentObjs, object) ? tax[label][object] : -Infinity;
  };

  // The meaning of a label is a function that maps objects to fitness values
  var meaning = function(label) {
    return function(object) {
      return labelFitness(label, object);
    };
  };

  var makeObjectPrior = function(item) {
    return Enumerate(function() {
      return uniformDraw(item);
    });
  };

  var constructLabelPrior = function(target) {
    var labels = refModule.getRelevantLabels(target, tax);
    return Enumerate(function(){
      var label = uniformDraw(labels);
      var prob = (label === domainInfo.superLabel ?
		  Math.log(superProb) :
		  Math.log((1 - superProb)/2));
      factor(prob);
      return label;
    });
  };

  var getLabelCost = cache(function(label) {
    var labelLength = refModule.getRelativeLength(label);
    var labelFreq = refModule.getRelativeLogFrequency(label);    
    return (freqWeight * labelFreq -
	    (1 - freqWeight) * labelLength);
  });

  var literalListener = cache(function(label, item){
    var objectPrior = makeObjectPrior(item);
    var labelMeaning = meaning(label);
    return Enumerate(function(){
      var object = sample(objectPrior);
      factor(labelMeaning(object));
      return object;
    });
  });                                         

  var speaker = cache(function(target, item) {
    var labelPrior = constructLabelPrior(target);
    return Enumerate(function(){
      var label = sample(labelPrior);
      var labelCost = getLabelCost(label);
      var possibleResponse = sample(literalListener(label, item));
      factor(possibleResponse === target ? alpha * labelCost : -Infinity);
      return label;
    });
  });

  return speaker;
};

var filename = "normalizedFreqLength_Additive.csv";
refModule.writeCSV([["domain", "condition", "target", "alpha",
		     "superProb", "freqWeight", "label", "modelProb"]],
		   filename);

var alphaRange = _.range(.5, 10, .5); // between 0 and 1
var superProbRange = _.range(0.01, 0.33, 0.01); // between 0 and 1/3
var freqWeightRange = _.range(0, 1, 0.1); // between 0 and 1/3

map(function(domain) {
  console.log("running domain... " + domain);
  var domainInfo = globalInfo.info[domain];
  map(function(condition) {
    console.log("running condition..." + condition);
    map(function(target) {
      map(function(alpha) {
	map(function(superProb) {
	  map(function(freqWeight) {
	    var item = cons(target, domainInfo.conditions[condition]);
	    var speakerModel = BasicLevelModel(domainInfo,alpha,superProb,freqWeight);
	    var speakerERP = speakerModel(target, item);
	    var transformedERP = Enumerate(function(){
	      var label = sample(speakerERP);
	      return (_.contains(domainInfo.targets, label) ? "type" :
		      label === domainInfo.basicLabel ? "basicLevel" :
		      label === domainInfo.superLabel ? "superDomain" :
		      "label not recognized");
	    });
	    refModule.writeERP(transformedERP,
			       [domain, condition, target,
	    			alpha.toFixed(2), superProb.toFixed(2),
				freqWeight.toFixed(2)], filename, 4);
	  }, freqWeightRange);
	}, superProbRange);
      }, alphaRange);
    }, domainInfo.targets);
  }, _.keys(domainInfo.conditions));
}, globalInfo.domains);
