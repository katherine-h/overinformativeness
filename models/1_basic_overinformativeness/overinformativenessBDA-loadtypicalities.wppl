// run using:
// webppl overinformativenessBDA-loadtypicalities.wppl --require ./refModule/

util.seedRNG(10);

var getTypicalities = function() {
    var typicalityData = refModule.readCSV("./bdaInput/typicalities.csv");
    // var typicalityData = refModule.readCSV("./bdaInput/typicalities_raw.csv");    
    // console.log(typicalityData);
    var unique_objects = _.unique(map(function(row) {
      return row[0];
    },typicalityData));

    var typicalities = [];
    // console.log(unique_objects);
    var consData = map(function(unique_obj) {
      // console.log(unique_obj);
      // var typ = function(row) {
      //   return (row[0] === unique_obj);
      // };
      // console.log(typ(typicalityData[2]));
      var matching_objs = refModule.getTypSubset(typicalityData,unique_obj);
      // var matching_objs = _.filter(typicalityData,typ);
      // console.log("an object");
      // console.log(matching_objs);

      // return matching_objs;

    // return _.filter(typicalityData,typ);
      var mo_array = map(function(matching_obj) {
        // console.log("an object's unique utterance");
        // console.log(matching_obj.slice(1,3));
        
          // return _.object([matching_obj[2]],[matching_obj[1]]);
          return matching_obj.slice(1,3);
      },matching_objs);
      // console.log("a zipped array of typicalities and utterances");
      // console.log(_.invert(_.object(mo_array)));
      // console.log(unique_obj);
      // console.log(_.object([unique_obj,_.invert(_.object(mo_array))]));
      return [unique_obj,_.invert(_.object(mo_array))];
    }, unique_objects);

    // // return typicalities;
    return _.object(consData);
};


var constructContext = function(condition,size,color,othercolor,item) {
    var context = [];
    var sufficientdimension = condition.substring(0,condition.length-2);
    var numDistractors = condition.substring(condition.length-2,condition.length-1);
    var numShared = condition.substring(condition.length-1,condition.length);
    var numDiff = numDistractors - numShared;
    // var othersize = size === "big" ? "small" : "big";
    var othersize = "othersize";
    // var othercolor = "othercolor";    
    context.push([size,color,item]); //add the target to the context

    // console.log(sufficientdimension);
    // console.log(numDistractors);
    // console.log(numShared);
    // console.log(numDiff);
    var buildUp = function(n,s,c,i) {      
      // console.log(context);
      // console.log(n);
      // console.log(s);
      // console.log(c);
      // console.log(i);
      if (n == 1) {
        context.push([s,c,i]);
      } else {
        context.push([s,c,i]);
        buildUp(n-1,s,c,i);
      }
    };   
 

  if (sufficientdimension == "size") {
      // console.log("at least getting in the right place");
      buildUp(numShared,othersize,color,item);
      // console.log("added shared features");
      if (numDiff > 0) { buildUp(numDiff,othersize,othercolor,item); }
    } else {
      buildUp(numShared,size,othercolor,item);
      if (numDiff > 0) { buildUp(numDiff,othersize,othercolor,item); }
    }
    return context;
  };


// var data = refModule.readCSV("./bdaInput/data_test.csv");
// var data = refModule.readCSV("./bdaInput/data_test_reduced.csv");
// var data = refModule.readCSV("./bdaInput/data_bda_modifiers.csv");
// var data = refModule.readCSV("./bdaInput/data_bda_modifiers_noother.csv"); // loads data with 46 "other utterance" cases excluded
// var data = refModule.readCSV("./bdaInput/data_bda_modifiers_reduced.csv");
var data = refModule.readCSV("./bdaInput/data_bda_modifiers_reduced_noother.csv");
console.log("Loading data complete...");

// var conditions = refModule.readCSV("./bdaInput/unique_conditions_test.csv");
// var conditions = refModule.readCSV("./bdaInput/unique_conditions_reduced_test.csv");
// var conditions = refModule.readCSV("./bdaInput/unique_conditions_modifiers.csv");
// var conditions = refModule.readCSV("./bdaInput/unique_conditions_modifiers_noother.csv"); // loads unique conditions with 46 "other utterance" cases excluded
// var conditions = refModule.readCSV("./bdaInput/unique_conditions_modifiers_reduced.csv");
var conditions = refModule.readCSV("./bdaInput/unique_conditions_modifiers_reduced_noother.csv");
console.log("Loading unique conditions complete...");
// console.log(conditions);

var typicality_norms = getTypicalities();//refModule.readCSV("./bdaInput/typicalities.csv");
console.log("Loading typicality norms complete...");
// console.log(typicality_norms);

var contextArrays = map(function(condition) {
  constructContext(condition[2],condition[1],condition[0],condition[3],condition[4]);
},conditions);
var contextKeys = map(function(condition) {
  [condition[2],condition[1],condition[0],condition[3],condition[4]].join("_");
},conditions);
var contexts = _.object(_.zip(contextKeys,contextArrays));
console.log("Constructing contexts complete...");
// console.log(contexts);

var modelAnalysis = function() {
  // console.log("Running next sample...");
  // Sample params
  // var params = {
  //   alpha : uniform(0,12),
  //   lengthWeight : uniform(0,5),
  //   typicality_color : uniform(0,1), // this doesn't matter when you use empirical typicalities
  //   typicality_size : uniform(0,1),
  //   typicality_type : 1,
  //   // typWeight : uniform(0,1),
  //   cost_color : uniform(0,2),
  //   cost_size : uniform(0,2),
  //   cost_type : 1
  // };
  //   var params = {
  //   alpha : sample(dirichletDriftERP, [1,1])[0]*12,
  //   lengthWeight : sample(dirichletDriftERP, [1,1])[0]*6,
  //   typicality_color : sample(dirichletDriftERP, [1,1])[0]*1, 
  //   typicality_size : sample(dirichletDriftERP, [1,1])[0]*1,
  //   typicality_type : 1,
  //   cost_color : sample(dirichletDriftERP, [1,1])[0]*3,
  //   cost_size : sample(dirichletDriftERP, [1,1])[0]*3,
  //   cost_type : 1
  // };

  var params = {
    alpha : sample(uniformDriftERP, [0,20,12/20 ]),
    lengthWeight : sample(uniformDriftERP, [0,10, 5/20]),
    typicality_color : sample(uniformDriftERP, [0,1,1/20]),
    typicality_size : sample(uniformDriftERP, [0,1,1/20]),
    typicality_type : 1,
    // typWeight : sample(uniformDriftERP, [0,1,1/20]),
    cost_color : sample(uniformDriftERP, [0,2, 2/20]),
    cost_size : sample(uniformDriftERP, [0,2, 2/20]),
    cost_type : 1
  };  

  // console.log(params);

  // Run model and condition on data
  var score = sum(map(function(condition) {
    // console.log("Creating next context...");
    // console.log(condition[2]);
    // console.log(condition[1]);
    // console.log(condition[0]);
    var context = contexts[[condition[2],condition[1],condition[0],condition[3],condition[4]].join("_")];
    // console.log("condition... " +condition);
    // console.log("Context construction complete... "+context);
    // console.log(context);
    var target = context[0];
    // console.log("Generating model...");
    var model = OverinformativeModel(params,context,typicality_norms);//domainInfo, params);
    var runModel = model.runModel;
    var speaker = model.speaker;
    // return sum(map(function(condition) {
    //   return sum(map(function(item) {
	    // Get model predictions
    // console.log("Running model...");
    var modelOutput = runModel(speaker, target);//, domainInfo);

    // console.log("Conditioning on data...");
	    // condition on data
    var itemData = refModule.getSubset(data, {condition:condition[2],
						  color:condition[0],
						  size:condition[1],
              item:condition[4]});
    // console.log(itemData.length);
	  var score = sum(map(function(dataRow) {
     // console.log("Conditioning on data row..."+dataRow);
	   var utterance = dataRow[7]+"_"+condition[4];
     // console.log("utterance..."+utterance);
     // console.log(_.contains(modelOutput.support(),utterance));
     // console.log(modelOutput.score([],utterance));
     // console.log(utterance+","+modelOutput.score([],utterance)+","+condition[2]);
	   return modelOutput.score([], utterance);
	  }, itemData));
    // display(score)
    // console.log(score);

	    // Store predictions
	  foreach(modelOutput.support([]), function(s){
      query.add([condition[0], condition[1], condition[3], condition[4], condition[2], s],
		  Math.exp(modelOutput.score([], s)));
	  });

	  return score;
  }, conditions));

  // display(score);

  factor(score)
  // factor(Math.max(score, -1000));

  // console.log(query.table);
  // console.log(params);
  return {predictive: query.table, params : params};
};

// var outputERP = MCMC(modelAnalysis, {samples: 1, burn: 1, verbose: true});
var outputERP = MCMC(modelAnalysis, {samples: 10000, burn: 3000, verbose: true});
// var outputERP = MCMC(modelAnalysis, {samples: 10, burn: 1, verbose: true});
// var outputERP = MCMC(modelAnalysis, {samples: 10000, verbose: true, burn: 3000,
                                     // kernel: { HMC: { steps: 1, stepSize: .01 }}});
// var outputERP = MCMC(modelAnalysis, {samples: 1, verbose: true,
//                                      kernel: { HMC: { steps: 1, stepSize: .01 }}});
// hmc only possible with very small number of samples (500), and then very few different values are considered

console.log('inference complete... printing');

// refModule.bayesianErpWriter(outputERP, "./bdaOutput/bda-hmc-test");

// reduced conditions -- 10'000 samples
// refModule.bayesianErpWriter(outputERP, "./bdaOutput/bda-fixed-reducedconditions");
refModule.bayesianErpWriter(outputERP, "./bdaOutput/bda-fixed-reducedconditions-unlogged");

// full conditions
// fixed typicality
// refModule.bayesianErpWriter(outputERP, "./bdaOutput/bda-fixed-fullconditions");

// empirical typicality
// refModule.bayesianErpWriter(outputERP, "./bdaOutput/bda-empirical-fullconditions");
// refModule.bayesianErpWriter(outputERP, "./bdaOutput/bda-empirical-fullconditions-scaledtyp");

// interpolation analysis (interploating between fixed and empirical typicality)
// refModule.bayesianErpWriter(outputERP, "./bdaOutput/bda-interpolated");
// refModule.bayesianErpWriter(outputERP, "./bdaOutput/bda-interpolated-scaledtyp");

